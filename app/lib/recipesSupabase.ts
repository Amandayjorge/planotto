"use client";

import { getSupabaseClient } from "./supabaseClient";
import { findIngredientIdByName } from "./ingredientDictionary";
import { normalizeRecipeTags } from "./recipeTags";
import {
  DEFAULT_UNIT_ID,
  getUnitLabelById,
  normalizeUnitId,
  type UnitId,
} from "./ingredientUnits";
import { findTemplateRecipeImage } from "./recipeImageCatalog";
import { hasInappropriateRecipeContent, INAPPROPRIATE_CONTENT_MESSAGE } from "./contentModeration";
import { normalizeNutritionRow, type NutritionInfo } from "./nutrition";

export const RECIPES_STORAGE_KEY = "recipes";
const RECIPE_REPORTS_KEY = "recipeReports";
const RECIPES_CLOUD_FALLBACK_KEY = "planotto_recipes_cloud_v1";

export type RecipeVisibility = "private" | "public" | "link" | "invited";
export type RecipeLanguage = "ru" | "en" | "es";

export interface Ingredient {
  ingredientId?: string;
  unitId?: UnitId;
  name: string;
  amount: number;
  unit: string;
  note?: string;
  optional?: boolean;
}

export interface RecipeTranslation {
  language: RecipeLanguage;
  title: string;
  shortDescription?: string;
  description?: string;
  instructions?: string;
  updatedAt?: string;
  isAutoGenerated?: boolean;
}

export interface RecipeModel {
  id: string;
  ownerId: string;
  authorId?: string;
  type?: "user" | "template";
  isTemplate?: boolean;
  title: string;
  shortDescription?: string;
  description?: string;
  instructions?: string;
  ingredients: Ingredient[];
  notes?: string;
  personalTags?: string[];
  servings: number;
  image?: string;
  categories: string[];
  tags: string[];
  baseLanguage?: RecipeLanguage;
  translations?: Partial<Record<RecipeLanguage, RecipeTranslation>>;
  visibility: RecipeVisibility;
  shareToken?: string;
  createdAt?: string;
  updatedAt?: string;
  nutrition?: NutritionInfo;
}

export interface RecipeUpsertInput {
  title: string;
  shortDescription?: string;
  description?: string;
  instructions?: string;
  ingredients: Ingredient[];
  notes?: string;
  servings?: number;
  image?: string;
  categories?: string[];
  tags?: string[];
  baseLanguage?: RecipeLanguage;
  translations?: Partial<Record<RecipeLanguage, RecipeTranslation>>;
  visibility?: RecipeVisibility;
  shareToken?: string;
  nutrition?: NutritionInfo;
}

export interface PublicAuthorProfile {
  userId: string;
  displayName: string;
  avatarUrl?: string;
  recipeCount: number;
}

interface RecipeRow {
  id: string;
  owner_id: string | null;
  author_id?: string | null;
  title: string;
  short_description: string | null;
  description: string | null;
  instructions: string | null;
  ingredients: Ingredient[] | null;
  servings: number | null;
  image: string | null;
  nutrition: NutritionInfo | null;
  categories: string[] | null;
  visibility: RecipeVisibility | null;
  share_token: string | null;
  created_at: string | null;
  updated_at: string | null;
}

interface RecipeAccessRow {
  recipe_id: string;
  user_id: string;
  role: "viewer" | "editor" | null;
}

interface RecipeAccessEmailRpcRow {
  email: string | null;
  role: "viewer" | "editor" | null;
}

interface RecipeNoteRow {
  recipe_id: string;
  notes: string | null;
  personal_tags: string[] | null;
}

interface RecipeTranslationRow {
  recipe_id: string;
  language: string;
  title: string;
  short_description: string | null;
  description: string | null;
  instructions: string | null;
  is_auto_generated: boolean | null;
  updated_at: string | null;
}

interface PublicAuthorProfileRow {
  user_id: string | null;
  display_name: string | null;
  avatar_url: string | null;
  recipe_count: number | null;
}

interface PostgrestLikeError {
  code?: string;
  message?: string;
}

export type RecipeReportReasonId =
  | "copyright"
  | "foreign_without_source"
  | "other";

interface RecipeReportRecord {
  recipeId: string;
  reason: RecipeReportReasonId;
  details: string;
  createdAt: string;
}

const normalizeRecipeReportReason = (value: unknown): RecipeReportReasonId => {
  const normalized = String(value || "").trim().toLowerCase();
  if (normalized === "copyright" || normalized === "нарушение авторских прав") {
    return "copyright";
  }
  if (normalized === "foreign_without_source" || normalized === "чужой рецепт без указания источника") {
    return "foreign_without_source";
  }
  return "other";
};

const RECIPE_COLUMNS =
  "id,owner_id,title,short_description,description,instructions,ingredients,servings,image,nutrition,categories,visibility,share_token,created_at,updated_at";
const RECIPE_COLUMNS_WITH_AUTHOR = `${RECIPE_COLUMNS},author_id`;
const RECIPE_TRANSLATION_COLUMNS =
  "recipe_id,language,title,short_description,description,instructions,is_auto_generated,updated_at";

type SeedTranslationPayload = {
  title: string;
  shortDescription: string;
  instructions: string;
};

const buildSeedTranslations = (translations: {
  ru: SeedTranslationPayload;
  en: SeedTranslationPayload;
  es: SeedTranslationPayload;
}): Pick<RecipeModel, "baseLanguage" | "translations"> => ({
  baseLanguage: "ru",
  translations: {
    ru: { language: "ru", ...translations.ru },
    en: { language: "en", ...translations.en },
    es: { language: "es", ...translations.es },
  },
});

const SEED_TEMPLATE_RECIPES: RecipeModel[] = [
  {
    id: "seed-omelet-vegetables",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Омлет с овощами",
    shortDescription: "Быстрый завтрак на каждый день",
    instructions:
      "Взбейте яйца с молоком и щепоткой соли. Обжарьте овощи 2-3 минуты, влейте яйца и готовьте под крышкой до готовности.",
    ingredients: [
      { name: "яйца", amount: 3, unit: "шт" },
      { name: "молоко", amount: 50, unit: "мл" },
      { name: "помидоры", amount: 1, unit: "шт" },
      { name: "болгарский перец", amount: 0.5, unit: "шт" },
      { name: "соль", amount: 0, unit: "по вкусу" },
    ],
    notes: "",
    servings: 2,
    image: "/recipes/templates/omelet-vegetables.jpg",
    categories: ["завтрак", "быстро (до 30 минут)", "на каждый день"],
    tags: ["завтрак", "быстро (до 30 минут)", "на каждый день"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Омлет с овощами",
        shortDescription: "Быстрый завтрак на каждый день",
        instructions:
          "Взбейте яйца с молоком и щепоткой соли. Обжарьте овощи 2-3 минуты, влейте яйца и готовьте под крышкой до готовности.",
      },
      en: {
        title: "Vegetable omelet",
        shortDescription: "Quick everyday breakfast",
        instructions:
          "Beat eggs with milk and a pinch of salt. Saute the vegetables for 2-3 minutes, pour in the eggs, cover, and cook until set.",
      },
      es: {
        title: "Tortilla con verduras",
        shortDescription: "Desayuno rapido para cada dia",
        instructions:
          "Bate los huevos con leche y una pizca de sal. Saltea las verduras durante 2-3 minutos, vierte los huevos, tapa y cocina hasta que cuaje.",
      },
    }),
  },
  {
    id: "seed-oatmeal-fruits",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Овсяная каша с фруктами",
    shortDescription: "Простой полезный завтрак",
    instructions:
      "Доведите молоко с водой до кипения, добавьте овсяные хлопья и варите 5-7 минут. Добавьте банан и яблоко перед подачей.",
    ingredients: [
      { name: "овсяные хлопья", amount: 80, unit: "г" },
      { name: "молоко", amount: 200, unit: "мл" },
      { name: "вода", amount: 100, unit: "мл" },
      { name: "банан", amount: 1, unit: "шт" },
      { name: "яблоко", amount: 1, unit: "шт" },
    ],
    notes: "",
    servings: 2,
    image: "/recipes/templates/oatmeal-fruits.jpg",
    categories: ["завтрак", "на каждый день"],
    tags: ["завтрак", "на каждый день"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Овсяная каша с фруктами",
        shortDescription: "Простой полезный завтрак",
        instructions:
          "Доведите молоко с водой до кипения, добавьте овсяные хлопья и варите 5-7 минут. Добавьте банан и яблоко перед подачей.",
      },
      en: {
        title: "Oatmeal with fruit",
        shortDescription: "Simple healthy breakfast",
        instructions:
          "Bring milk and water to a boil, add rolled oats, and cook for 5-7 minutes. Add banana and apple before serving.",
      },
      es: {
        title: "Avena con fruta",
        shortDescription: "Desayuno simple y saludable",
        instructions:
          "Lleva la leche con agua a ebullicion, agrega avena y cocina 5-7 minutos. Anade el platano y la manzana antes de servir.",
      },
    }),
  },
  {
    id: "seed-chicken-rice",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Курица с рисом",
    shortDescription: "Базовый обед без сложной техники",
    instructions:
      "Обжарьте курицу до легкой корочки, добавьте лук и морковь. Засыпьте рис, влейте воду, накройте крышкой и готовьте 20 минут.",
    ingredients: [
      { name: "куриное филе", amount: 400, unit: "г" },
      { name: "рис", amount: 200, unit: "г" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "морковь", amount: 1, unit: "шт" },
      { name: "вода", amount: 450, unit: "мл" },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/chicken-rice.jpg",
    categories: ["обед", "на каждый день"],
    tags: ["обед", "на каждый день"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Курица с рисом",
        shortDescription: "Базовый обед без сложной техники",
        instructions:
          "Обжарьте курицу до легкой корочки, добавьте лук и морковь. Засыпьте рис, влейте воду, накройте крышкой и готовьте 20 минут.",
      },
      en: {
        title: "Chicken with rice",
        shortDescription: "Basic lunch without complex steps",
        instructions:
          "Brown the chicken lightly, add onion and carrot. Add rice, pour in water, cover, and cook for 20 minutes.",
      },
      es: {
        title: "Pollo con arroz",
        shortDescription: "Almuerzo basico sin tecnicas complejas",
        instructions:
          "Dora ligeramente el pollo y agrega cebolla y zanahoria. Anade arroz, vierte agua, tapa y cocina durante 20 minutos.",
      },
    }),
  },
  {
    id: "seed-baked-fish-potatoes",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Запеченная рыба с картофелем",
    shortDescription: "Ужин в духовке без лишней суеты",
    instructions:
      "Нарежьте картофель, выложите в форму, сверху рыбу. Посолите, добавьте масло и запекайте 30-35 минут при 190°C.",
    ingredients: [
      { name: "рыбное филе", amount: 500, unit: "г" },
      { name: "картофель", amount: 700, unit: "г" },
      { name: "масло растительное", amount: 20, unit: "мл" },
      { name: "соль", amount: 0, unit: "по вкусу" },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/baked-fish-potatoes.jpg",
    categories: ["ужин", "духовка"],
    tags: ["ужин", "духовка"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Запеченная рыба с картофелем",
        shortDescription: "Ужин в духовке без лишней суеты",
        instructions:
          "Нарежьте картофель, выложите в форму, сверху рыбу. Посолите, добавьте масло и запекайте 30-35 минут при 190°C.",
      },
      en: {
        title: "Baked fish with potatoes",
        shortDescription: "Easy oven dinner",
        instructions:
          "Slice the potatoes, place them in a baking dish, and put fish on top. Season with salt, add oil, and bake at 190C for 30-35 minutes.",
      },
      es: {
        title: "Pescado al horno con patatas",
        shortDescription: "Cena facil al horno",
        instructions:
          "Corta las patatas, colocalas en una fuente y pon el pescado encima. Sala, agrega aceite y hornea 30-35 minutos a 190C.",
      },
    }),
  },
  {
    id: "seed-pasta-tomato",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Паста с томатным соусом",
    shortDescription: "Универсальный быстрый ужин",
    instructions:
      "Отварите пасту. На сковороде прогрейте томаты с чесноком и маслом 8-10 минут. Смешайте пасту с соусом.",
    ingredients: [
      { name: "паста", amount: 250, unit: "г" },
      { name: "томаты в собственном соку", amount: 400, unit: "г" },
      { name: "чеснок", amount: 2, unit: "зубчик" },
      { name: "масло оливковое", amount: 15, unit: "мл" },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/pasta-tomato.jpg",
    categories: ["ужин", "быстро (до 30 минут)"],
    tags: ["ужин", "быстро (до 30 минут)"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Паста с томатным соусом",
        shortDescription: "Универсальный быстрый ужин",
        instructions:
          "Отварите пасту. На сковороде прогрейте томаты с чесноком и маслом 8-10 минут. Смешайте пасту с соусом.",
      },
      en: {
        title: "Pasta with tomato sauce",
        shortDescription: "Fast all-purpose dinner",
        instructions:
          "Boil the pasta. Warm tomatoes with garlic and oil in a pan for 8-10 minutes. Toss pasta with the sauce.",
      },
      es: {
        title: "Pasta con salsa de tomate",
        shortDescription: "Cena rapida y versatil",
        instructions:
          "Hierve la pasta. Calienta tomate con ajo y aceite en una sarten durante 8-10 minutos. Mezcla la pasta con la salsa.",
      },
    }),
  },
  {
    id: "seed-tuna-salad",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Салат с тунцом",
    shortDescription: "Быстрый вариант на обед или ужин",
    instructions:
      "Нарежьте овощи, добавьте тунец и яйцо. Заправьте маслом и лимонным соком, перемешайте.",
    ingredients: [
      { name: "тунец консервированный", amount: 1, unit: "шт" },
      { name: "огурец", amount: 1, unit: "шт" },
      { name: "помидоры", amount: 2, unit: "шт" },
      { name: "яйца", amount: 2, unit: "шт" },
      { name: "масло оливковое", amount: 10, unit: "мл" },
    ],
    notes: "",
    servings: 2,
    image: "/recipes/templates/tuna-salad.jpg",
    categories: ["обед", "быстро (до 30 минут)"],
    tags: ["обед", "быстро (до 30 минут)"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Салат с тунцом",
        shortDescription: "Быстрый вариант на обед или ужин",
        instructions:
          "Нарежьте овощи, добавьте тунец и яйцо. Заправьте маслом и лимонным соком, перемешайте.",
      },
      en: {
        title: "Tuna salad",
        shortDescription: "Quick lunch or dinner option",
        instructions:
          "Chop the vegetables, add tuna and egg. Dress with olive oil and lemon juice, then toss.",
      },
      es: {
        title: "Ensalada con atun",
        shortDescription: "Opcion rapida para almuerzo o cena",
        instructions:
          "Corta las verduras, agrega atun y huevo. Adereza con aceite y jugo de limon, luego mezcla.",
      },
    }),
  },
  {
    id: "seed-oladi-kefir",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Оладьи на кефире",
    shortDescription: "Базовая выпечка к чаю",
    instructions:
      "Смешайте кефир, яйцо, сахар и муку с разрыхлителем. Жарьте оладьи на среднем огне с двух сторон до румяности.",
    ingredients: [
      { name: "кефир", amount: 250, unit: "мл" },
      { name: "мука", amount: 180, unit: "г" },
      { name: "яйца", amount: 1, unit: "шт" },
      { name: "сахар", amount: 20, unit: "г" },
      { name: "разрыхлитель", amount: 1, unit: "ч.л." },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/oladi-kefir.jpg",
    categories: ["завтрак", "выпечка"],
    tags: ["завтрак", "выпечка"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Оладьи на кефире",
        shortDescription: "Базовая выпечка к чаю",
        instructions:
          "Смешайте кефир, яйцо, сахар и муку с разрыхлителем. Жарьте оладьи на среднем огне с двух сторон до румяности.",
      },
      en: {
        title: "Kefir pancakes",
        shortDescription: "Simple tea-time pancakes",
        instructions:
          "Mix kefir, egg, sugar, and flour with baking powder. Fry pancakes on medium heat on both sides until golden.",
      },
      es: {
        title: "Tortitas de kefir",
        shortDescription: "Tortitas sencillas para el te",
        instructions:
          "Mezcla kefir, huevo, azucar y harina con polvo de hornear. Frie las tortitas a fuego medio por ambos lados hasta dorar.",
      },
    }),
  },
  {
    id: "seed-greek-yogurt-granola",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Йогурт с гранолой",
    shortDescription: "Завтрак за 5 минут",
    instructions:
      "Разложите йогурт по мискам, добавьте гранолу и ягоды. Полейте медом перед подачей.",
    ingredients: [
      { name: "йогурт", amount: 300, unit: "г" },
      { name: "гранола", amount: 80, unit: "г" },
      { name: "ягоды", amount: 100, unit: "г" },
      { name: "мед", amount: 1, unit: "ст.л." },
    ],
    notes: "",
    servings: 2,
    image: "/recipes/templates/oatmeal-fruits.jpg",
    categories: ["завтрак", "быстро (до 30 минут)"],
    tags: ["завтрак", "быстро (до 30 минут)"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Йогурт с гранолой",
        shortDescription: "Завтрак за 5 минут",
        instructions:
          "Разложите йогурт по мискам, добавьте гранолу и ягоды. Полейте медом перед подачей.",
      },
      en: {
        title: "Yogurt with granola",
        shortDescription: "Breakfast in 5 minutes",
        instructions:
          "Divide yogurt into bowls, add granola and berries. Drizzle with honey before serving.",
      },
      es: {
        title: "Yogur con granola",
        shortDescription: "Desayuno en 5 minutos",
        instructions:
          "Reparte el yogur en cuencos, agrega granola y frutos rojos. Anade miel antes de servir.",
      },
    }),
  },
  {
    id: "seed-buckwheat-mushrooms",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Гречка с грибами",
    shortDescription: "Сытный гарнир или самостоятельное блюдо",
    instructions:
      "Отварите гречку. Обжарьте лук с грибами 7-8 минут, смешайте с гречкой, посолите и прогрейте 2 минуты.",
    ingredients: [
      { name: "гречка", amount: 200, unit: "г" },
      { name: "шампиньоны", amount: 250, unit: "г" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "масло растительное", amount: 15, unit: "мл" },
      { name: "соль", amount: 0, unit: "по вкусу" },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/chicken-rice.jpg",
    categories: ["обед", "на каждый день"],
    tags: ["обед", "на каждый день"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Гречка с грибами",
        shortDescription: "Сытный гарнир или самостоятельное блюдо",
        instructions:
          "Отварите гречку. Обжарьте лук с грибами 7-8 минут, смешайте с гречкой, посолите и прогрейте 2 минуты.",
      },
      en: {
        title: "Buckwheat with mushrooms",
        shortDescription: "Hearty side dish or main",
        instructions:
          "Cook buckwheat. Saute onion with mushrooms for 7-8 minutes, mix with buckwheat, season with salt, and heat for 2 more minutes.",
      },
      es: {
        title: "Trigo sarraceno con champinones",
        shortDescription: "Guarnicion abundante o plato principal",
        instructions:
          "Cuece el trigo sarraceno. Saltea cebolla con champinones durante 7-8 minutos, mezcla con el cereal, sala y calienta 2 minutos mas.",
      },
    }),
  },
  {
    id: "seed-mashed-potatoes",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Картофельное пюре",
    shortDescription: "Классический мягкий гарнир",
    instructions:
      "Отварите картофель до мягкости. Слейте воду, добавьте молоко и масло, разомните до однородности.",
    ingredients: [
      { name: "картофель", amount: 800, unit: "г" },
      { name: "молоко", amount: 120, unit: "мл" },
      { name: "масло сливочное", amount: 25, unit: "г" },
      { name: "соль", amount: 0, unit: "по вкусу" },
    ],
    notes: "",
    servings: 4,
    image: "/recipes/templates/baked-fish-potatoes.jpg",
    categories: ["обед", "гарнир"],
    tags: ["обед", "гарнир"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Картофельное пюре",
        shortDescription: "Классический мягкий гарнир",
        instructions:
          "Отварите картофель до мягкости. Слейте воду, добавьте молоко и масло, разомните до однородности.",
      },
      en: {
        title: "Mashed potatoes",
        shortDescription: "Classic smooth side dish",
        instructions:
          "Boil potatoes until tender. Drain, add milk and butter, and mash until smooth.",
      },
      es: {
        title: "Pure de patatas",
        shortDescription: "Guarnicion clasica y cremosa",
        instructions:
          "Hierve las patatas hasta que esten tiernas. Escurre, agrega leche y mantequilla, y tritura hasta que quede suave.",
      },
    }),
  },
  {
    id: "seed-vegetable-soup",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Овощной суп",
    shortDescription: "Легкий суп на каждый день",
    instructions:
      "Нарежьте овощи, залейте водой и доведите до кипения. Варите 20 минут до мягкости, добавьте соль и зелень.",
    ingredients: [
      { name: "картофель", amount: 300, unit: "г" },
      { name: "морковь", amount: 1, unit: "шт" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "кабачок", amount: 200, unit: "г" },
      { name: "вода", amount: 1200, unit: "мл" },
    ],
    notes: "",
    servings: 4,
    image: "/recipes/templates/lentil-soup-v2.jpg",
    categories: ["обед", "суп"],
    tags: ["обед", "суп"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Овощной суп",
        shortDescription: "Легкий суп на каждый день",
        instructions:
          "Нарежьте овощи, залейте водой и доведите до кипения. Варите 20 минут до мягкости, добавьте соль и зелень.",
      },
      en: {
        title: "Vegetable soup",
        shortDescription: "Light everyday soup",
        instructions:
          "Chop the vegetables, add water, and bring to a boil. Simmer for 20 minutes until tender, then season with salt and herbs.",
      },
      es: {
        title: "Sopa de verduras",
        shortDescription: "Sopa ligera para cada dia",
        instructions:
          "Corta las verduras, cubrelas con agua y lleva a ebullicion. Cocina 20 minutos hasta que esten tiernas y agrega sal y hierbas.",
      },
    }),
  },
  {
    id: "seed-fried-rice-egg",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Жареный рис с яйцом",
    shortDescription: "Быстрый ужин на сковороде",
    instructions:
      "Обжарьте лук и морковь 3 минуты. Добавьте готовый рис и яйцо, быстро перемешайте до готовности яйца.",
    ingredients: [
      { name: "рис", amount: 250, unit: "г" },
      { name: "яйца", amount: 2, unit: "шт" },
      { name: "морковь", amount: 1, unit: "шт" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "масло растительное", amount: 15, unit: "мл" },
    ],
    notes: "",
    servings: 2,
    image: "/recipes/templates/chicken-rice.jpg",
    categories: ["ужин", "быстро (до 30 минут)"],
    tags: ["ужин", "быстро (до 30 минут)"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Жареный рис с яйцом",
        shortDescription: "Быстрый ужин на сковороде",
        instructions:
          "Обжарьте лук и морковь 3 минуты. Добавьте готовый рис и яйцо, быстро перемешайте до готовности яйца.",
      },
      en: {
        title: "Fried rice with egg",
        shortDescription: "Quick skillet dinner",
        instructions:
          "Saute onion and carrot for 3 minutes. Add cooked rice and egg, then stir quickly until the egg is cooked.",
      },
      es: {
        title: "Arroz frito con huevo",
        shortDescription: "Cena rapida en sarten",
        instructions:
          "Saltea cebolla y zanahoria durante 3 minutos. Agrega arroz cocido y huevo, mezcla rapido hasta que el huevo este listo.",
      },
    }),
  },
  {
    id: "seed-turkey-sandwich",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Сэндвич с индейкой",
    shortDescription: "Простой перекус или легкий обед",
    instructions:
      "Подсушите хлеб, намажьте сыр, добавьте листья салата, индейку и помидор. Накройте вторым ломтиком.",
    ingredients: [
      { name: "хлеб", amount: 4, unit: "ломтик" },
      { name: "индейка", amount: 120, unit: "г" },
      { name: "творожный сыр", amount: 60, unit: "г" },
      { name: "помидоры", amount: 1, unit: "шт" },
      { name: "листья салата", amount: 4, unit: "шт" },
    ],
    notes: "",
    servings: 2,
    image: "/recipes/templates/tuna-salad.jpg",
    categories: ["обед", "быстро (до 30 минут)"],
    tags: ["обед", "быстро (до 30 минут)"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Сэндвич с индейкой",
        shortDescription: "Простой перекус или легкий обед",
        instructions:
          "Подсушите хлеб, намажьте сыр, добавьте листья салата, индейку и помидор. Накройте вторым ломтиком.",
      },
      en: {
        title: "Turkey sandwich",
        shortDescription: "Simple snack or light lunch",
        instructions:
          "Toast the bread, spread cream cheese, add lettuce, turkey, and tomato. Top with the second slice.",
      },
      es: {
        title: "Sandwich de pavo",
        shortDescription: "Tentempie simple o almuerzo ligero",
        instructions:
          "Tuesta el pan, unta queso crema, agrega lechuga, pavo y tomate. Cubre con la segunda rebanada.",
      },
    }),
  },
  {
    id: "seed-cottage-cheese-berries",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Творог с ягодами",
    shortDescription: "Белковый завтрак без готовки",
    instructions:
      "Выложите творог в миску, добавьте ягоды и мед. Перемешайте или подавайте слоями.",
    ingredients: [
      { name: "творог", amount: 250, unit: "г" },
      { name: "ягоды", amount: 120, unit: "г" },
      { name: "мед", amount: 1, unit: "ст.л." },
    ],
    notes: "",
    servings: 2,
    image: "/recipes/templates/oatmeal-fruits.jpg",
    categories: ["завтрак", "на каждый день"],
    tags: ["завтрак", "на каждый день"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Творог с ягодами",
        shortDescription: "Белковый завтрак без готовки",
        instructions:
          "Выложите творог в миску, добавьте ягоды и мед. Перемешайте или подавайте слоями.",
      },
      en: {
        title: "Cottage cheese with berries",
        shortDescription: "Protein breakfast without cooking",
        instructions:
          "Place cottage cheese in a bowl, add berries and honey. Mix or serve in layers.",
      },
      es: {
        title: "Requeson con frutos rojos",
        shortDescription: "Desayuno proteico sin cocinar",
        instructions:
          "Pon el requeson en un cuenco, agrega frutos rojos y miel. Mezcla o sirve en capas.",
      },
    }),
  },
  {
    id: "seed-roasted-vegetables",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Запеченные овощи",
    shortDescription: "Универсальный гарнир из духовки",
    instructions:
      "Нарежьте овощи крупно, добавьте масло и соль. Запекайте при 200°C 25-30 минут, перемешав один раз.",
    ingredients: [
      { name: "картофель", amount: 400, unit: "г" },
      { name: "кабачок", amount: 250, unit: "г" },
      { name: "болгарский перец", amount: 1, unit: "шт" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "масло растительное", amount: 20, unit: "мл" },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/baked-fish-potatoes.jpg",
    categories: ["ужин", "духовка"],
    tags: ["ужин", "духовка"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Запеченные овощи",
        shortDescription: "Универсальный гарнир из духовки",
        instructions:
          "Нарежьте овощи крупно, добавьте масло и соль. Запекайте при 200°C 25-30 минут, перемешав один раз.",
      },
      en: {
        title: "Roasted vegetables",
        shortDescription: "Versatile oven side dish",
        instructions:
          "Cut vegetables into large pieces, add oil and salt. Roast at 200C for 25-30 minutes, stirring once.",
      },
      es: {
        title: "Verduras al horno",
        shortDescription: "Guarnicion versatil al horno",
        instructions:
          "Corta las verduras en trozos grandes, agrega aceite y sal. Hornea a 200C durante 25-30 minutos y mezcla una vez.",
      },
    }),
  },
  {
    id: "seed-lentil-soup",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Суп из чечевицы",
    shortDescription: "Сытный постный суп",
    instructions:
      "Промойте чечевицу, добавьте в воду с овощами и варите 25 минут. В конце добавьте соль и специи.",
    ingredients: [
      { name: "чечевица", amount: 220, unit: "г" },
      { name: "морковь", amount: 1, unit: "шт" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "томатная паста", amount: 1, unit: "ст.л." },
      { name: "вода", amount: 1300, unit: "мл" },
    ],
    notes: "",
    servings: 4,
    image: "/recipes/templates/lentil-soup-v2.jpg",
    categories: ["обед", "суп"],
    tags: ["обед", "суп"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Суп из чечевицы",
        shortDescription: "Сытный постный суп",
        instructions:
          "Промойте чечевицу, добавьте в воду с овощами и варите 25 минут. В конце добавьте соль и специи.",
      },
      en: {
        title: "Lentil soup",
        shortDescription: "Hearty meat-free soup",
        instructions:
          "Rinse lentils, add them to water with vegetables, and cook for 25 minutes. Add salt and spices at the end.",
      },
      es: {
        title: "Sopa de lentejas",
        shortDescription: "Sopa abundante sin carne",
        instructions:
          "Enjuaga las lentejas, agregalas al agua con verduras y cocina 25 minutos. Al final agrega sal y especias.",
      },
    }),
  },
  {
    id: "seed-chicken-noodle-soup",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Куриный суп с лапшой",
    shortDescription: "Домашний суп на каждый день",
    instructions:
      "Сварите курицу 20 минут, добавьте овощи и лапшу. Готовьте еще 10 минут и подавайте с зеленью.",
    ingredients: [
      { name: "куриное филе", amount: 300, unit: "г" },
      { name: "лапша", amount: 120, unit: "г" },
      { name: "морковь", amount: 1, unit: "шт" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "вода", amount: 1500, unit: "мл" },
    ],
    notes: "",
    servings: 4,
    image: "/recipes/templates/lentil-soup.jpg",
    categories: ["обед", "суп"],
    tags: ["обед", "суп"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Куриный суп с лапшой",
        shortDescription: "Домашний суп на каждый день",
        instructions:
          "Сварите курицу 20 минут, добавьте овощи и лапшу. Готовьте еще 10 минут и подавайте с зеленью.",
      },
      en: {
        title: "Chicken noodle soup",
        shortDescription: "Homestyle everyday soup",
        instructions:
          "Cook chicken for 20 minutes, add vegetables and noodles. Cook 10 more minutes and serve with herbs.",
      },
      es: {
        title: "Sopa de pollo con fideos",
        shortDescription: "Sopa casera para cada dia",
        instructions:
          "Cocina el pollo durante 20 minutos, agrega verduras y fideos. Cocina 10 minutos mas y sirve con hierbas.",
      },
    }),
  },
  {
    id: "seed-rice-vegetables",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Рис с овощами",
    shortDescription: "Простой вегетарианский ужин",
    instructions:
      "Обжарьте овощи 5 минут, добавьте рис и воду. Готовьте под крышкой 18-20 минут до мягкости риса.",
    ingredients: [
      { name: "рис", amount: 220, unit: "г" },
      { name: "болгарский перец", amount: 1, unit: "шт" },
      { name: "морковь", amount: 1, unit: "шт" },
      { name: "лук", amount: 1, unit: "шт" },
      { name: "вода", amount: 450, unit: "мл" },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/chicken-rice.jpg",
    categories: ["ужин", "на каждый день"],
    tags: ["ужин", "на каждый день"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Рис с овощами",
        shortDescription: "Простой вегетарианский ужин",
        instructions:
          "Обжарьте овощи 5 минут, добавьте рис и воду. Готовьте под крышкой 18-20 минут до мягкости риса.",
      },
      en: {
        title: "Rice with vegetables",
        shortDescription: "Simple vegetarian dinner",
        instructions:
          "Saute vegetables for 5 minutes, add rice and water. Cook covered for 18-20 minutes until rice is tender.",
      },
      es: {
        title: "Arroz con verduras",
        shortDescription: "Cena vegetariana simple",
        instructions:
          "Saltea las verduras durante 5 minutos, agrega arroz y agua. Cocina tapado 18-20 minutos hasta que el arroz este tierno.",
      },
    }),
  },
  {
    id: "seed-crepes-milk",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Блины на молоке",
    shortDescription: "Тонкие блины для завтрака",
    instructions:
      "Смешайте яйца, молоко, муку и сахар до жидкого теста. Жарьте тонкие блины на разогретой сковороде.",
    ingredients: [
      { name: "молоко", amount: 500, unit: "мл" },
      { name: "яйца", amount: 2, unit: "шт" },
      { name: "мука", amount: 200, unit: "г" },
      { name: "сахар", amount: 20, unit: "г" },
      { name: "масло растительное", amount: 20, unit: "мл" },
    ],
    notes: "",
    servings: 4,
    image: "/recipes/templates/oladi-kefir.jpg",
    categories: ["завтрак", "выпечка"],
    tags: ["завтрак", "выпечка"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Блины на молоке",
        shortDescription: "Тонкие блины для завтрака",
        instructions:
          "Смешайте яйца, молоко, муку и сахар до жидкого теста. Жарьте тонкие блины на разогретой сковороде.",
      },
      en: {
        title: "Milk crepes",
        shortDescription: "Thin breakfast crepes",
        instructions:
          "Whisk eggs, milk, flour, and sugar into a thin batter. Cook thin crepes on a hot pan.",
      },
      es: {
        title: "Crepes con leche",
        shortDescription: "Crepes finos para desayuno",
        instructions:
          "Mezcla huevos, leche, harina y azucar hasta obtener una masa liquida. Cocina crepes finos en una sarten caliente.",
      },
    }),
  },
  {
    id: "seed-tuna-pasta-creamy",
    ownerId: "system",
    type: "template",
    isTemplate: true,
    title: "Паста с тунцом",
    shortDescription: "Быстрый ужин из простых продуктов",
    instructions:
      "Отварите пасту. Прогрейте тунец со сливками 3-4 минуты, добавьте пасту и перемешайте.",
    ingredients: [
      { name: "паста", amount: 250, unit: "г" },
      { name: "тунец консервированный", amount: 1, unit: "шт" },
      { name: "сливки 20%", amount: 150, unit: "мл" },
      { name: "чеснок", amount: 1, unit: "зубчик" },
    ],
    notes: "",
    servings: 3,
    image: "/recipes/templates/pasta-tomato.jpg",
    categories: ["ужин", "быстро (до 30 минут)"],
    tags: ["ужин", "быстро (до 30 минут)"],
    visibility: "public",
    ...buildSeedTranslations({
      ru: {
        title: "Паста с тунцом",
        shortDescription: "Быстрый ужин из простых продуктов",
        instructions:
          "Отварите пасту. Прогрейте тунец со сливками 3-4 минуты, добавьте пасту и перемешайте.",
      },
      en: {
        title: "Pasta with tuna",
        shortDescription: "Quick dinner from simple ingredients",
        instructions:
          "Boil the pasta. Warm tuna with cream for 3-4 minutes, add pasta, and mix well.",
      },
      es: {
        title: "Pasta con atun",
        shortDescription: "Cena rapida con ingredientes simples",
        instructions:
          "Hierve la pasta. Calienta atun con nata durante 3-4 minutos, agrega la pasta y mezcla bien.",
      },
    }),
  },
];

SEED_TEMPLATE_RECIPES.forEach((recipe) => {
  const mapped = findTemplateRecipeImage(recipe.id, recipe.title);
  if (mapped.matched) {
    recipe.image = mapped.image || "";
  }
});

const cloneRecipeModel = (recipe: RecipeModel): RecipeModel => ({
  ...recipe,
  ingredients: (recipe.ingredients || []).map((item) => ({ ...item })),
  categories: [...(recipe.categories || [])],
  tags: [...(recipe.tags || [])],
  translations: recipe.translations
    ? {
        ...(recipe.translations.ru ? { ru: { ...recipe.translations.ru } } : {}),
        ...(recipe.translations.en ? { en: { ...recipe.translations.en } } : {}),
        ...(recipe.translations.es ? { es: { ...recipe.translations.es } } : {}),
      }
    : undefined,
});

export const listSeedTemplateRecipes = (): RecipeModel[] =>
  SEED_TEMPLATE_RECIPES.map((item) => cloneRecipeModel(item));

const getSeedTemplateRecipeById = (recipeId: string): RecipeModel | null => {
  const found = SEED_TEMPLATE_RECIPES.find((item) => item.id === recipeId);
  return found ? cloneRecipeModel(found) : null;
};

const readRecipeReports = (): RecipeReportRecord[] => {
  if (typeof window === "undefined") return [];
  try {
    const raw = localStorage.getItem(RECIPE_REPORTS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed
      .map((item) => item as Partial<RecipeReportRecord>)
      .filter((item) => typeof item.recipeId === "string" && item.recipeId.trim().length > 0)
      .map((item) => ({
        recipeId: String(item.recipeId),
        reason: normalizeRecipeReportReason(item.reason),
        details: String(item.details || ""),
        createdAt: String(item.createdAt || new Date().toISOString()),
      }));
  } catch {
    return [];
  }
};

const writeRecipeReports = (reports: RecipeReportRecord[]) => {
  if (typeof window === "undefined") return;
  localStorage.setItem(RECIPE_REPORTS_KEY, JSON.stringify(reports));
};

export const getReportedRecipeIds = (): string[] => {
  const unique = new Set(readRecipeReports().map((item) => item.recipeId));
  return Array.from(unique);
};

export const isRecipeHiddenByReport = (recipeId: string): boolean =>
  getReportedRecipeIds().includes(recipeId);

const saveRecipeReportToCloud = async (
  recipeId: string,
  reason: RecipeReportReasonId,
  details = ""
): Promise<void> => {
  const supabase = getSupabaseClient();
  const { data, error: authError } = await supabase.auth.getUser();
  if (authError) throw authError;

  const reporterId = data.user?.id || null;
  const payload = {
    recipe_id: recipeId,
    reporter_id: reporterId,
    reason,
    details: details.trim(),
    status: "open",
  };

  if (reporterId) {
    const { error } = await supabase
      .from("recipe_reports")
      .upsert(payload, { onConflict: "recipe_id,reporter_id" });
    if (error) throw error;
    return;
  }

  const { error } = await supabase.from("recipe_reports").insert(payload);
  if (error) throw error;
};

export const reportRecipeForReview = async (
  recipeId: string,
  reason: RecipeReportReasonId,
  details = ""
): Promise<void> => {
  const current = readRecipeReports();
  const next: RecipeReportRecord[] = [
    ...current.filter((item) => item.recipeId !== recipeId),
    {
      recipeId,
      reason,
      details: details.trim(),
      createdAt: new Date().toISOString(),
    },
  ];
  writeRecipeReports(next);

  try {
    await saveRecipeReportToCloud(recipeId, reason, details);
  } catch {
    // Keep report flow non-blocking if cloud moderation table is unavailable.
  }
};

const isMissingRelationError = (error: unknown, relationName: string): boolean => {
  if (!error || typeof error !== "object") return false;
  const typed = error as PostgrestLikeError;
  const message = String(typed.message || "").toLowerCase();
  const relation = relationName.toLowerCase();
  return typed.code === "42P01" || message.includes(relation) || message.includes("does not exist");
};

const isMissingFunctionError = (error: unknown, functionName: string): boolean => {
  if (!error || typeof error !== "object") return false;
  const typed = error as PostgrestLikeError;
  const message = String(typed.message || "").toLowerCase();
  const name = functionName.toLowerCase();
  return typed.code === "42883" || message.includes(name) || message.includes("function") && message.includes("does not exist");
};

const isMissingColumnError = (error: unknown, columnName: string): boolean => {
  if (!error || typeof error !== "object") return false;
  const typed = error as PostgrestLikeError;
  const message = String(typed.message || "").toLowerCase();
  const column = columnName.toLowerCase();
  return typed.code === "42703" || (message.includes("column") && message.includes(column));
};

const isDuplicateKeyError = (error: unknown): boolean => {
  if (!error || typeof error !== "object") return false;
  const typed = error as PostgrestLikeError;
  const message = String(typed.message || "").toLowerCase();
  return typed.code === "23505" || message.includes("duplicate key");
};

const assertRecipeOwnerIsNotBlocked = async (ownerId: string): Promise<void> => {
  const normalizedOwnerId = String(ownerId || "").trim();
  if (!normalizedOwnerId) return;

  const supabase = getSupabaseClient();
  const { data, error } = await supabase
    .from("user_profiles")
    .select("is_blocked")
    .eq("user_id", normalizedOwnerId)
    .maybeSingle();

  if (error) {
    if (isMissingRelationError(error, "user_profiles")) return;
    const code = String((error as { code?: unknown }).code || "");
    if (code === "PGRST116") return;
    throw error;
  }

  const isBlocked = Boolean((data as { is_blocked?: unknown } | null)?.is_blocked);
  if (isBlocked) {
    throw new Error("Account is blocked.");
  }
};

const normalizeTitle = (value: string): string =>
  value.trim().toLocaleLowerCase("ru-RU").replace(/\s+/g, " ");

const normalizeVisibility = (value: unknown): RecipeVisibility => {
  if (value === "public" || value === "link" || value === "invited" || value === "private") {
    return value;
  }
  return "private";
};

const normalizeRecipeLanguage = (value: unknown): RecipeLanguage => {
  if (value === "ru" || value === "en" || value === "es") return value;
  return "ru";
};

const UUID_LIKE_PATTERN =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

const isUuidLike = (value: string): boolean => UUID_LIKE_PATTERN.test(value.trim());

const normalizeRecipeTranslation = (
  language: RecipeLanguage,
  value: unknown
): RecipeTranslation | null => {
  if (!value || typeof value !== "object") return null;
  const raw = value as Record<string, unknown>;
  const title = String(raw.title || "").trim();
  if (!title) return null;
  return {
    language,
    title,
    shortDescription: String(raw.shortDescription || "").trim() || undefined,
    description: String(raw.description || "").trim() || undefined,
    instructions: String(raw.instructions || "").trim() || undefined,
    updatedAt: String(raw.updatedAt || "").trim() || undefined,
    isAutoGenerated: Boolean(raw.isAutoGenerated),
  };
};

const normalizeRecipeTranslations = (
  value: unknown
): Partial<Record<RecipeLanguage, RecipeTranslation>> | undefined => {
  if (!value || typeof value !== "object") return undefined;
  const raw = value as Record<string, unknown>;
  const result: Partial<Record<RecipeLanguage, RecipeTranslation>> = {};
  (["ru", "en", "es"] as const).forEach((language) => {
    const normalized = normalizeRecipeTranslation(language, raw[language]);
    if (normalized) result[language] = normalized;
  });
  return Object.keys(result).length > 0 ? result : undefined;
};

const buildRecipeTranslations = (input: {
  baseLanguage?: unknown;
  translations?: unknown;
  title?: string;
  shortDescription?: string;
  description?: string;
  instructions?: string;
  updatedAt?: string;
}): Partial<Record<RecipeLanguage, RecipeTranslation>> => {
  const baseLanguage = normalizeRecipeLanguage(input.baseLanguage);
  const normalized = normalizeRecipeTranslations(input.translations) || {};
  const baseTitle = String(input.title || "").trim();
  const baseShortDescription = String(input.shortDescription || "").trim();
  const baseDescription = String(input.description || "").trim();
  const baseInstructions = String(input.instructions || "").trim();
  const baseUpdatedAt = String(input.updatedAt || "").trim();

  if (!normalized[baseLanguage] && baseTitle) {
    normalized[baseLanguage] = {
      language: baseLanguage,
      title: baseTitle,
      shortDescription: baseShortDescription || undefined,
      description: baseDescription || undefined,
      instructions: baseInstructions || undefined,
      updatedAt: baseUpdatedAt || undefined,
    };
  }

  return normalized;
};

const getRecipeSortTimestamp = (recipe: RecipeModel): number => {
  const updatedAt = Date.parse(recipe.updatedAt || "");
  if (Number.isFinite(updatedAt) && updatedAt > 0) return updatedAt;
  const createdAt = Date.parse(recipe.createdAt || "");
  if (Number.isFinite(createdAt) && createdAt > 0) return createdAt;
  return 0;
};

const dedupeRecipesByTitle = (recipes: RecipeModel[]): RecipeModel[] => {
  const sorted = [...recipes].sort((a, b) => getRecipeSortTimestamp(b) - getRecipeSortTimestamp(a));
  const byKey = new Map<string, RecipeModel>();

  sorted.forEach((recipe) => {
    const titleKey = normalizeTitle(recipe.title || "");
    const key = titleKey || `id:${recipe.id}`;
    if (!byKey.has(key)) {
      byKey.set(key, recipe);
    }
  });

  return Array.from(byKey.values());
};

const findOwnedRecipeByTitle = async (ownerId: string, title: string): Promise<RecipeModel | null> => {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase
    .from("recipes")
    .select(RECIPE_COLUMNS)
    .eq("owner_id", ownerId)
    .limit(100);

  if (error) {
    throw error;
  }

  const rows = Array.isArray(data) ? (data as RecipeRow[]) : [];
  const targetTitle = normalizeTitle(title);
  const matched = rows.find((row) => normalizeTitle(row.title || "") === targetTitle);
  return matched ? mapRow(matched) : null;
};

const findOwnedRecipeByTitleSafe = async (ownerId: string, title: string): Promise<RecipeModel | null> => {
  try {
    return await findOwnedRecipeByTitle(ownerId, title);
  } catch (error) {
    if (!isMissingRelationError(error, "recipes")) {
      throw error;
    }
    const cloud = await loadCloudFallbackRecipes(ownerId);
    const targetTitle = normalizeTitle(title);
    return cloud.find((item) => normalizeTitle(item.title || "") === targetTitle) || null;
  }
};

const normalizeIngredients = (value: unknown): Ingredient[] => {
  if (!Array.isArray(value)) return [];
  const normalized: Ingredient[] = [];

  value.forEach((item) => {
    if (!item || typeof item !== "object") return;
    const raw = item as Record<string, unknown>;
    const name = String(raw.name || "").trim();
    if (!name) return;

    const unit = String(raw.unit || "").trim();
    const unitIdRaw = String(raw.unitId || raw.unit_id || "").trim();
    const amount = Number(raw.amount || 0);
    const ingredientIdRaw = String(raw.ingredientId || raw.ingredient_id || "").trim();
    const note = String(raw.note || "").trim();
    const optional = Boolean(raw.optional);
    const normalizedUnitId = normalizeUnitId(unitIdRaw || unit || DEFAULT_UNIT_ID, DEFAULT_UNIT_ID);
    const normalizedUnit = unit || getUnitLabelById(normalizedUnitId, "ru");

    normalized.push({
      ingredientId:
        ingredientIdRaw ||
        findIngredientIdByName(name, "ru") ||
        findIngredientIdByName(name, "en") ||
        findIngredientIdByName(name, "es") ||
        undefined,
      unitId: normalizedUnitId,
      name,
      unit: normalizedUnit,
      amount: Number.isFinite(amount) ? amount : 0,
      note: note || undefined,
      optional,
    });
  });

  return normalized;
};

const hasMissingStructuredIngredientFields = (value: unknown): boolean => {
  if (!Array.isArray(value)) return false;

  return value.some((item) => {
    if (!item || typeof item !== "object") return false;
    const raw = item as Record<string, unknown>;
    const name = String(raw.name || "").trim();
    if (!name) return false;

    const ingredientIdRaw = String(raw.ingredientId || raw.ingredient_id || "").trim();
    const unitIdRaw = String(raw.unitId || raw.unit_id || "").trim();
    const unitRaw = String(raw.unit || "").trim();

    if (
      !ingredientIdRaw &&
      (findIngredientIdByName(name, "ru") ||
        findIngredientIdByName(name, "en") ||
        findIngredientIdByName(name, "es"))
    ) {
      return true;
    }
    if (!unitIdRaw) return true;

    const normalizedUnitId = normalizeUnitId(unitIdRaw || unitRaw || DEFAULT_UNIT_ID, DEFAULT_UNIT_ID);
    if (normalizedUnitId !== unitIdRaw) return true;

    return false;
  });
};

const persistBackfilledIngredientsIfNeeded = async (
  ownerId: string,
  rows: RecipeRow[]
): Promise<void> => {
  const candidates = rows
    .filter((row) => hasMissingStructuredIngredientFields(row.ingredients))
    .map((row) => ({
      recipeId: row.id,
      ingredients: normalizeIngredients(row.ingredients),
    }));

  if (candidates.length === 0) return;

  const supabase = getSupabaseClient();
  await Promise.allSettled(
    candidates.map(({ recipeId, ingredients }) =>
      supabase
        .from("recipes")
        .update({ ingredients })
        .eq("id", recipeId)
        .eq("owner_id", ownerId)
    )
  );
};

const normalizeStringArray = (value: unknown): string[] => {
  if (!Array.isArray(value)) return [];
  return value
    .map((item) => String(item || "").trim())
    .filter((item) => item.length > 0);
};

const normalizePersonalTags = (value: unknown): string[] => {
  const seen = new Set<string>();
  const result: string[] = [];
  normalizeStringArray(value).forEach((item) => {
    const normalizedKey = item.toLocaleLowerCase("ru-RU").replace(/\s+/g, " ").trim();
    if (!normalizedKey || seen.has(normalizedKey)) return;
    seen.add(normalizedKey);
    result.push(item.replace(/\s+/g, " ").trim());
  });
  return result;
};

const normalizeRecipeTagArray = (value: unknown): string[] =>
  normalizeRecipeTags(normalizeStringArray(value));

const serializeRecipeForCloudFallback = (recipe: RecipeModel): Record<string, unknown> => ({
  id: recipe.id,
  authorId: String(recipe.authorId || recipe.ownerId || "").trim(),
  title: recipe.title || "Рецепт",
  shortDescription: recipe.shortDescription || "",
  description: recipe.description || "",
  instructions: recipe.instructions || "",
  ingredients: normalizeIngredients(recipe.ingredients),
  notes: recipe.notes || "",
  personalTags: normalizePersonalTags(recipe.personalTags),
  servings: recipe.servings && recipe.servings > 0 ? recipe.servings : 2,
  image: recipe.image || "",
  nutrition: recipe.nutrition ? recipe.nutrition : undefined,
  categories: normalizeRecipeTagArray(recipe.categories),
  tags: normalizeRecipeTagArray(recipe.tags || recipe.categories),
  baseLanguage: normalizeRecipeLanguage(recipe.baseLanguage),
  translations: buildRecipeTranslations({
    baseLanguage: recipe.baseLanguage,
    translations: recipe.translations,
    title: recipe.title,
    shortDescription: recipe.shortDescription,
    description: recipe.description,
    instructions: recipe.instructions,
    updatedAt: recipe.updatedAt,
  }),
  visibility: normalizeVisibility(recipe.visibility),
  shareToken: (recipe.shareToken || "").trim(),
  createdAt: recipe.createdAt || new Date().toISOString(),
  updatedAt: recipe.updatedAt || new Date().toISOString(),
});

const mapCloudFallbackItemToRecipe = (ownerId: string, value: unknown): RecipeModel | null => {
  if (!value || typeof value !== "object") return null;
  const raw = value as Record<string, unknown>;
  const id = String(raw.id || "").trim();
  const title = String(raw.title || "").trim();
  if (!id || !title) return null;

  const categories = normalizeRecipeTagArray(raw.categories);
  const tags = normalizeRecipeTagArray(raw.tags ?? raw.categories);
  const shareToken = String(raw.shareToken || "").trim();
  const baseLanguage = normalizeRecipeLanguage(raw.baseLanguage);
  const translations = buildRecipeTranslations({
    baseLanguage,
    translations: raw.translations,
    title,
    shortDescription: String(raw.shortDescription || ""),
    description: String(raw.description || ""),
    instructions: String(raw.instructions || raw.description || ""),
    updatedAt: String(raw.updatedAt || ""),
  });

  return {
    id,
    ownerId,
    authorId: String(raw.authorId || raw.ownerId || ownerId).trim() || ownerId,
    type: "user",
    isTemplate: false,
    title,
    shortDescription: String(raw.shortDescription || ""),
    description: String(raw.description || ""),
    instructions: String(raw.instructions || raw.description || ""),
    ingredients: normalizeIngredients(raw.ingredients),
    notes: String(raw.notes || ""),
    personalTags: normalizePersonalTags(raw.personalTags),
    servings: Number(raw.servings || 2),
    image: String(raw.image || ""),
    nutrition: raw.nutrition ? normalizeNutritionRow(raw.nutrition) : undefined,
    categories,
    tags: tags.length > 0 ? tags : categories,
    baseLanguage,
    translations: Object.keys(translations).length > 0 ? translations : undefined,
    visibility: normalizeVisibility(raw.visibility),
    shareToken: shareToken || undefined,
    createdAt: String(raw.createdAt || ""),
    updatedAt: String(raw.updatedAt || ""),
  };
};

const loadCloudFallbackRecipes = async (ownerId: string): Promise<RecipeModel[]> => {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase.auth.getUser();
  if (error || !data.user || data.user.id !== ownerId) return [];
  const metadata = (data.user.user_metadata || {}) as Record<string, unknown>;
  const rawList = metadata[RECIPES_CLOUD_FALLBACK_KEY];
  if (!Array.isArray(rawList)) return [];
  const needsBackfill = rawList.some((item) => {
    if (!item || typeof item !== "object") return false;
    const raw = item as Record<string, unknown>;
    return hasMissingStructuredIngredientFields(raw.ingredients);
  });
  const mapped = dedupeRecipesByTitle(
    rawList
    .map((item) => mapCloudFallbackItemToRecipe(ownerId, item))
    .filter((item): item is RecipeModel => Boolean(item))
  );
  if (needsBackfill) {
    try {
      await saveCloudFallbackRecipes(ownerId, mapped);
    } catch {
      // Keep read path non-blocking if metadata update fails.
    }
  }
  return mapped;
};

const saveCloudFallbackRecipes = async (ownerId: string, recipes: RecipeModel[]): Promise<void> => {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase.auth.getUser();
  if (error || !data.user || data.user.id !== ownerId) {
    throw error || new Error("Supabase user is not available.");
  }

  const existingMetadata = (data.user.user_metadata || {}) as Record<string, unknown>;
  const payload = recipes.map((item) => serializeRecipeForCloudFallback(item));
  const { error: updateError } = await supabase.auth.updateUser({
    data: {
      ...existingMetadata,
      [RECIPES_CLOUD_FALLBACK_KEY]: payload,
    },
  });

  if (updateError) {
    throw updateError;
  }
};

const mapRow = (row: RecipeRow, notes?: string | null, personalTags?: string[] | null): RecipeModel => {
  const tags = normalizeRecipeTagArray(row.categories);
  const isTemplate = !row.owner_id;
  const baseLanguage: RecipeLanguage = "ru";
  return {
    id: row.id,
    ownerId: row.owner_id || "system",
    authorId: row.author_id || row.owner_id || undefined,
    type: isTemplate ? "template" : "user",
    isTemplate,
    title: row.title,
    shortDescription: row.short_description || "",
    description: row.description || "",
    instructions: row.instructions || "",
    ingredients: normalizeIngredients(row.ingredients),
    notes: notes || "",
    personalTags: normalizePersonalTags(personalTags),
    servings: row.servings && row.servings > 0 ? row.servings : 2,
    image: row.image || "",
    categories: tags,
    tags,
    baseLanguage,
    translations: {
      [baseLanguage]: {
        language: baseLanguage,
        title: row.title || "",
        shortDescription: row.short_description || undefined,
        description: row.description || undefined,
        instructions: row.instructions || undefined,
        updatedAt: row.updated_at || undefined,
      },
    },
    nutrition: row.nutrition ? normalizeNutritionRow(row.nutrition) : undefined,
    visibility: normalizeVisibility(row.visibility),
    shareToken: row.share_token || undefined,
    createdAt: row.created_at || undefined,
    updatedAt: row.updated_at || undefined,
  };
};

const mapRecipeTranslationRows = (
  rows: RecipeTranslationRow[] | null | undefined
): Partial<Record<RecipeLanguage, RecipeTranslation>> | undefined => {
  if (!rows || rows.length === 0) return undefined;
  const translations: Partial<Record<RecipeLanguage, RecipeTranslation>> = {};
  rows.forEach((row) => {
    const language = normalizeRecipeLanguage(row.language);
    const normalized = normalizeRecipeTranslation(language, {
      title: row.title,
      shortDescription: row.short_description,
      description: row.description,
      instructions: row.instructions,
      updatedAt: row.updated_at,
      isAutoGenerated: row.is_auto_generated,
    });
    if (normalized) translations[language] = normalized;
  });
  return Object.keys(translations).length > 0 ? translations : undefined;
};

const mergeRecipeTranslations = (
  recipe: RecipeModel,
  dbTranslations?: Partial<Record<RecipeLanguage, RecipeTranslation>>
): RecipeModel => {
  const merged = buildRecipeTranslations({
    baseLanguage: recipe.baseLanguage,
    translations: {
      ...(recipe.translations || {}),
      ...(dbTranslations || {}),
    },
    title: recipe.title,
    shortDescription: recipe.shortDescription,
    description: recipe.description,
    instructions: recipe.instructions,
    updatedAt: recipe.updatedAt,
  });

  return {
    ...recipe,
    translations: Object.keys(merged).length > 0 ? merged : undefined,
  };
};

const toPayload = (input: RecipeUpsertInput) => {
  const tags = normalizeRecipeTagArray(input.tags ?? input.categories);
  return {
    title: input.title.trim(),
    short_description: (input.shortDescription || "").trim(),
    description: (input.description || "").trim(),
    instructions: (input.instructions || "").trim(),
    ingredients: normalizeIngredients(input.ingredients),
    servings: input.servings && input.servings > 0 ? input.servings : 2,
    image: (input.image || "").trim(),
    categories: tags,
    visibility: normalizeVisibility(input.visibility),
    share_token: (input.shareToken || "").trim() || null,
    nutrition: input.nutrition || null,
  };
};

export const syncRecipesToLocalCache = (recipes: RecipeModel[]): void => {
  if (typeof window === "undefined") return;
  const mapped = dedupeRecipesByTitle(recipes).map((item) => ({
    id: item.id,
    title: item.title,
    shortDescription: item.shortDescription || "",
    description: item.description || "",
    instructions: item.instructions || "",
    ingredients: item.ingredients || [],
    notes: item.notes || "",
    personalTags: normalizePersonalTags(item.personalTags),
    servings: item.servings || 2,
    image: item.image || "",
    categories: item.categories || [],
    tags: item.tags || item.categories || [],
    baseLanguage: normalizeRecipeLanguage(item.baseLanguage),
    translations: buildRecipeTranslations({
      baseLanguage: item.baseLanguage,
      translations: item.translations,
      title: item.title,
      shortDescription: item.shortDescription,
      description: item.description,
      instructions: item.instructions,
      updatedAt: item.updatedAt,
    }),
    visibility: normalizeVisibility(item.visibility),
    shareToken: (item.shareToken || "").trim(),
    nutrition: item.nutrition,
  }));
  localStorage.setItem(RECIPES_STORAGE_KEY, JSON.stringify(mapped));
};

export const upsertRecipeInLocalCache = (recipe: RecipeModel): void => {
  if (typeof window === "undefined") return;
  const current = loadLocalRecipes();
  const recipeTitleKey = normalizeTitle(recipe.title || "");
  const withoutCurrent = current.filter((item) => {
    if (item.id === recipe.id) return false;
    if (!recipeTitleKey) return true;
    return normalizeTitle(item.title || "") !== recipeTitleKey;
  });
  syncRecipesToLocalCache([recipe, ...withoutCurrent]);
};

export const removeRecipeFromLocalCache = (recipeId: string): void => {
  if (typeof window === "undefined") return;
  const current = loadLocalRecipes().filter((item) => item.id !== recipeId);
  syncRecipesToLocalCache(current);
};

export const loadLocalRecipes = (): RecipeModel[] => {
  if (typeof window === "undefined") return [];
  const raw = localStorage.getItem(RECIPES_STORAGE_KEY);
  if (!raw) return [];
  try {
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    let needsIngredientBackfill = false;
    const mapped = dedupeRecipesByTitle(parsed.map((item) => {
      const row = item as Record<string, unknown>;
      const rawIngredients = Array.isArray(row.ingredients)
        ? row.ingredients.filter((entry) => entry && typeof entry === "object") as Array<Record<string, unknown>>
        : [];
      if (!needsIngredientBackfill) {
        needsIngredientBackfill = hasMissingStructuredIngredientFields(rawIngredients);
      }
      return {
        id: String(row.id || crypto.randomUUID()),
        ownerId: "",
        type: "user",
        isTemplate: false,
        title: String(row.title || ""),
        shortDescription: String(row.shortDescription || ""),
        description: String(row.description || ""),
        instructions: String(row.instructions || row.description || ""),
        ingredients: normalizeIngredients(row.ingredients),
        notes: String(row.notes || ""),
        personalTags: normalizePersonalTags(row.personalTags),
        servings: Number(row.servings || 2),
        image: String(row.image || ""),
        categories: normalizeStringArray(row.categories),
        tags: normalizeStringArray(row.tags ?? row.categories),
        baseLanguage: normalizeRecipeLanguage(row.baseLanguage),
        translations: buildRecipeTranslations({
          baseLanguage: row.baseLanguage,
          translations: row.translations,
          title: String(row.title || ""),
          shortDescription: String(row.shortDescription || ""),
          description: String(row.description || ""),
          instructions: String(row.instructions || row.description || ""),
          updatedAt: String(row.updatedAt || ""),
        }),
        visibility: normalizeVisibility(row.visibility),
        shareToken: String(row.shareToken || "").trim() || undefined,
        nutrition: normalizeNutritionRow(row.nutrition),
      };
    }));

    // Backward-compatible migration: persist inferred ingredient IDs for legacy local recipes.
    if (needsIngredientBackfill) {
      syncRecipesToLocalCache(mapped);
    }
    return mapped;
  } catch {
    return [];
  }
};

export const getCurrentUserId = async (): Promise<string | null> => {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase.auth.getUser();
  if (error || !data.user) return null;
  return data.user.id;
};

export const listMyRecipes = async (ownerId: string): Promise<RecipeModel[]> => {
  const supabase = getSupabaseClient();

  const { data: recipeRows, error: recipesError } = await supabase
    .from("recipes")
    .select(RECIPE_COLUMNS)
    .eq("owner_id", ownerId)
    .order("updated_at", { ascending: false });

  if (recipesError) {
    if (isMissingRelationError(recipesError, "recipes")) {
      return loadCloudFallbackRecipes(ownerId);
    }
    throw recipesError;
  }

  const rows = (recipeRows || []) as RecipeRow[];
  if (rows.length === 0) return [];

  try {
    await persistBackfilledIngredientsIfNeeded(ownerId, rows);
  } catch {
    // Non-blocking migration: listing recipes should still work.
  }

  const ids = rows.map((row) => row.id);
  const { data: noteRows, error: notesError } = await supabase
    .from("recipe_notes")
    .select("*")
    .eq("owner_id", ownerId)
    .in("recipe_id", ids);

  if (notesError) {
    if (!isMissingRelationError(notesError, "recipe_notes")) {
      throw notesError;
    }
    return rows.map((row) => mapRow(row));
  }

  const notesMap = new Map<string, { notes: string; personalTags: string[] }>();
  (noteRows as RecipeNoteRow[]).forEach((row) => {
    notesMap.set(row.recipe_id, {
      notes: row.notes || "",
      personalTags: normalizePersonalTags(row.personal_tags),
    });
  });

  return dedupeRecipesByTitle(
    rows.map((row) => {
      const meta = notesMap.get(row.id);
      return mapRow(row, meta?.notes, meta?.personalTags);
    })
  );
};

export const listPublicRecipes = async (): Promise<RecipeModel[]> => {
  const supabase = getSupabaseClient();
  let publicRecipesResponse = await supabase
    .from("recipes")
    .select(RECIPE_COLUMNS_WITH_AUTHOR)
    .eq("visibility", "public")
    .order("updated_at", { ascending: false });

  if (publicRecipesResponse.error && isMissingColumnError(publicRecipesResponse.error, "author_id")) {
    publicRecipesResponse = await supabase
      .from("recipes")
      .select(RECIPE_COLUMNS)
      .eq("visibility", "public")
      .order("updated_at", { ascending: false }) as typeof publicRecipesResponse;
  }

  const { data, error } = publicRecipesResponse;

  if (error) {
    if (isMissingRelationError(error, "recipes")) {
      return listSeedTemplateRecipes();
    }
    throw error;
  }

  const hidden = new Set(getReportedRecipeIds());
  const dbPublic = ((data || []) as RecipeRow[])
    .map((row) => mapRow(row))
    .filter((row) => !hidden.has(row.id));

  const seedTemplates = listSeedTemplateRecipes();
  const knownTitles = new Set(dbPublic.map((item) => item.title.trim().toLowerCase()));
  const extraTemplates = seedTemplates.filter((item) => !knownTitles.has(item.title.trim().toLowerCase()));

  return [...extraTemplates, ...dbPublic];
};

const mapPublicAuthorProfileRow = (row: PublicAuthorProfileRow): PublicAuthorProfile | null => {
  const userId = String(row.user_id || "").trim();
  if (!userId) return null;
  return {
    userId,
    displayName: String(row.display_name || "").trim() || "Planotto",
    avatarUrl: String(row.avatar_url || "").trim() || undefined,
    recipeCount: Math.max(0, Number(row.recipe_count || 0)),
  };
};

export const listPublicAuthorProfiles = async (
  userIds: string[]
): Promise<Record<string, PublicAuthorProfile>> => {
  const normalizedIds = Array.from(
    new Set(
      userIds
        .map((item) => String(item || "").trim())
        .filter((item) => item.length > 0 && item !== "system" && isUuidLike(item))
    )
  );
  const result: Record<string, PublicAuthorProfile> = {};
  if (normalizedIds.length === 0) return result;

  const supabase = getSupabaseClient();
  const { data, error } = await supabase.rpc("list_public_author_profiles", {
    p_user_ids: normalizedIds,
  });

  if (error) {
    if (isMissingFunctionError(error, "list_public_author_profiles")) return result;
    throw error;
  }

  const rows = Array.isArray(data) ? (data as PublicAuthorProfileRow[]) : [];
  rows.forEach((row) => {
    const mapped = mapPublicAuthorProfileRow(row);
    if (!mapped) return;
    result[mapped.userId] = mapped;
  });
  return result;
};

export const getPublicAuthorProfile = async (authorId: string): Promise<PublicAuthorProfile | null> => {
  const normalizedAuthorId = String(authorId || "").trim();
  if (!normalizedAuthorId) return null;
  if (normalizedAuthorId === "system") {
    const publicSeedCount = listSeedTemplateRecipes().filter((item) => item.visibility === "public").length;
    return {
      userId: "system",
      displayName: "Planotto",
      recipeCount: publicSeedCount,
      avatarUrl: "/mascot/otto-bubble.png",
    };
  }
  if (!isUuidLike(normalizedAuthorId)) return null;

  const profiles = await listPublicAuthorProfiles([normalizedAuthorId]);
  return profiles[normalizedAuthorId] || null;
};

export const listPublicRecipesByAuthor = async (authorId: string): Promise<RecipeModel[]> => {
  const normalizedAuthorId = String(authorId || "").trim();
  if (!normalizedAuthorId) return [];
  if (normalizedAuthorId === "system") {
    return listSeedTemplateRecipes().filter((item) => item.visibility === "public");
  }
  if (!isUuidLike(normalizedAuthorId)) return [];

  const supabase = getSupabaseClient();
  let authorRecipesResponse = await supabase
    .from("recipes")
    .select(RECIPE_COLUMNS_WITH_AUTHOR)
    .eq("visibility", "public")
    .eq("author_id", normalizedAuthorId)
    .order("updated_at", { ascending: false });

  if (authorRecipesResponse.error && isMissingColumnError(authorRecipesResponse.error, "author_id")) {
    authorRecipesResponse = await supabase
      .from("recipes")
      .select(RECIPE_COLUMNS)
      .eq("visibility", "public")
      .eq("owner_id", normalizedAuthorId)
      .order("updated_at", { ascending: false }) as typeof authorRecipesResponse;
  }

  const { data, error } = authorRecipesResponse;

  if (error) {
    if (isMissingRelationError(error, "recipes")) return [];
    throw error;
  }

  const hidden = new Set(getReportedRecipeIds());
  return ((data || []) as RecipeRow[])
    .map((row) => mapRow(row))
    .filter((row) => !hidden.has(row.id));
};

export const getRecipeById = async (
  recipeId: string,
  currentUserId?: string | null,
  shareToken?: string | null
): Promise<RecipeModel | null> => {
  const seedTemplate = getSeedTemplateRecipeById(recipeId);
  if (seedTemplate) {
    return seedTemplate;
  }

  const supabase = getSupabaseClient();

  let query = supabase.from("recipes").select(RECIPE_COLUMNS).eq("id", recipeId);
  const normalizedShareToken = String(shareToken || "").trim();
  if (!currentUserId) {
    if (normalizedShareToken) {
      query = query.eq("visibility", "link").eq("share_token", normalizedShareToken);
    } else {
      query = query.eq("visibility", "public");
    }
  }

  const { data, error } = await query.maybeSingle();
  if (error) {
    if (isMissingRelationError(error, "recipes") && currentUserId) {
      const cloudRecipes = await loadCloudFallbackRecipes(currentUserId);
      return cloudRecipes.find((item) => item.id === recipeId) || null;
    }
    throw error;
  }
  if (!data) return null;

  const row = data as RecipeRow;
  const rowVisibility = normalizeVisibility(row.visibility);
  const isOwner = Boolean(currentUserId && row.owner_id === currentUserId);

  if (isOwner && currentUserId && hasMissingStructuredIngredientFields(row.ingredients)) {
    const normalizedIngredients = normalizeIngredients(row.ingredients);
    try {
      await supabase
        .from("recipes")
        .update({ ingredients: normalizedIngredients })
        .eq("id", recipeId)
        .eq("owner_id", currentUserId);
      row.ingredients = normalizedIngredients;
    } catch {
      // Do not break read path on best-effort backfill.
    }
  }

  if (rowVisibility === "link" && !isOwner) {
    if (!normalizedShareToken || row.share_token !== normalizedShareToken) {
      return null;
    }
  }

  if (rowVisibility === "public" && (!currentUserId || row.owner_id !== currentUserId)) {
    if (isRecipeHiddenByReport(row.id)) return null;
  }
  let notes = "";
  let personalTags: string[] = [];

  if (isOwner && currentUserId) {
    const { data: noteData, error: noteError } = await supabase
      .from("recipe_notes")
      .select("*")
      .eq("recipe_id", recipeId)
      .eq("owner_id", currentUserId)
      .maybeSingle();

    if (noteError) {
      if (!isMissingRelationError(noteError, "recipe_notes")) {
        throw noteError;
      }
    } else {
      const meta = noteData as RecipeNoteRow | null;
      notes = meta?.notes || "";
      personalTags = normalizePersonalTags(meta?.personal_tags);
    }
  }

  const mapped = mapRow(row, notes, personalTags);
  try {
    const translations = await listRecipeTranslations(recipeId);
    return mergeRecipeTranslations(mapped, translations);
  } catch (error) {
    if (isMissingRelationError(error, "recipe_translations")) {
      return mapped;
    }
    throw error;
  }
};

export const listRecipeTranslations = async (
  recipeId: string
): Promise<Partial<Record<RecipeLanguage, RecipeTranslation>>> => {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase
    .from("recipe_translations")
    .select(RECIPE_TRANSLATION_COLUMNS)
    .eq("recipe_id", recipeId);

  if (error) {
    if (isMissingRelationError(error, "recipe_translations")) {
      return {};
    }
    throw error;
  }

  return mapRecipeTranslationRows((data || []) as RecipeTranslationRow[]) || {};
};

export const upsertRecipeTranslation = async (
  _ownerId: string,
  recipeId: string,
  translation: RecipeTranslation
): Promise<RecipeTranslation> => {
  const language = normalizeRecipeLanguage(translation.language);
  const payload = {
    recipe_id: recipeId,
    language,
    title: String(translation.title || "").trim(),
    short_description: String(translation.shortDescription || "").trim() || null,
    description: String(translation.description || "").trim() || null,
    instructions: String(translation.instructions || "").trim() || null,
    is_auto_generated: Boolean(translation.isAutoGenerated),
  };

  if (!payload.title) {
    throw new Error("Recipe translation title is required.");
  }

  const supabase = getSupabaseClient();
  const { data, error } = await supabase
    .from("recipe_translations")
    .upsert(payload, { onConflict: "recipe_id,language" })
    .select(RECIPE_TRANSLATION_COLUMNS)
    .single();

  if (error) {
    if (isMissingRelationError(error, "recipe_translations")) {
      return {
        language,
        title: payload.title,
        shortDescription: payload.short_description || undefined,
        description: payload.description || undefined,
        instructions: payload.instructions || undefined,
        isAutoGenerated: payload.is_auto_generated,
        updatedAt: new Date().toISOString(),
      };
    }
    throw error;
  }

  const row = data as RecipeTranslationRow;
  const normalized = normalizeRecipeTranslation(language, {
    title: row.title,
    shortDescription: row.short_description,
    description: row.description,
    instructions: row.instructions,
    updatedAt: row.updated_at,
    isAutoGenerated: row.is_auto_generated,
  });

  if (!normalized) {
    throw new Error("Failed to normalize saved recipe translation.");
  }

  return normalized;
};

export const createRecipe = async (ownerId: string, input: RecipeUpsertInput): Promise<RecipeModel> => {
  const supabase = getSupabaseClient();
  await assertRecipeOwnerIsNotBlocked(ownerId);
  const payload = toPayload(input);

  if (
    normalizeVisibility(payload.visibility) === "public" &&
    hasInappropriateRecipeContent({
      title: payload.title,
      shortDescription: payload.short_description,
      description: payload.description,
      instructions: payload.instructions,
      notes: input.notes,
      tags: payload.categories,
      ingredients: payload.ingredients,
    })
  ) {
    throw new Error(INAPPROPRIATE_CONTENT_MESSAGE);
  }

  let createResponse = await supabase
    .from("recipes")
    .insert({ ...payload, owner_id: ownerId, author_id: ownerId })
    .select(RECIPE_COLUMNS)
    .single();

  if (createResponse.error && isMissingColumnError(createResponse.error, "author_id")) {
    createResponse = await supabase
      .from("recipes")
      .insert({ ...payload, owner_id: ownerId })
      .select(RECIPE_COLUMNS)
      .single();
  }

  const { data, error } = createResponse;

  if (error) {
    if (isMissingRelationError(error, "recipes")) {
      const now = new Date().toISOString();
      const cloudRecipes = await loadCloudFallbackRecipes(ownerId);
      const baseLanguage = normalizeRecipeLanguage(input.baseLanguage);
      const translations = buildRecipeTranslations({
        baseLanguage,
        translations: input.translations,
        title: payload.title,
        shortDescription: payload.short_description,
        description: payload.description,
        instructions: payload.instructions,
        updatedAt: now,
      });
      const created: RecipeModel = {
        id: crypto.randomUUID(),
        ownerId,
        authorId: ownerId,
        type: "user",
        isTemplate: false,
        title: payload.title || "Рецепт",
        shortDescription: payload.short_description || "",
        description: payload.description || "",
        instructions: payload.instructions || payload.description || "",
        ingredients: normalizeIngredients(payload.ingredients),
        notes: (input.notes || "").trim(),
        personalTags: [],
        servings: payload.servings && payload.servings > 0 ? payload.servings : 2,
        image: payload.image || "",
        categories: normalizeStringArray(payload.categories),
        tags: normalizeStringArray(payload.categories),
        baseLanguage,
        translations,
        visibility: normalizeVisibility(payload.visibility),
        shareToken: payload.share_token || undefined,
        createdAt: now,
        updatedAt: now,
      };
      await saveCloudFallbackRecipes(ownerId, [created, ...cloudRecipes]);
      return created;
    }
    throw error;
  }

  const created = data as RecipeRow;
  const notes = (input.notes || "").trim();

  if (notes) {
    const { error: notesError } = await supabase
      .from("recipe_notes")
      .upsert({ recipe_id: created.id, owner_id: ownerId, notes }, { onConflict: "recipe_id" });

    if (notesError) {
      if (!isMissingRelationError(notesError, "recipe_notes")) {
        throw notesError;
      }
    }
  }

  return mapRow(created, notes, []);
};

export const updateRecipe = async (ownerId: string, recipeId: string, input: RecipeUpsertInput): Promise<RecipeModel> => {
  const supabase = getSupabaseClient();
  await assertRecipeOwnerIsNotBlocked(ownerId);
  const payload = toPayload(input);

  if (
    normalizeVisibility(payload.visibility) === "public" &&
    hasInappropriateRecipeContent({
      title: payload.title,
      shortDescription: payload.short_description,
      description: payload.description,
      instructions: payload.instructions,
      notes: input.notes,
      tags: payload.categories,
      ingredients: payload.ingredients,
    })
  ) {
    throw new Error(INAPPROPRIATE_CONTENT_MESSAGE);
  }

  const { data, error } = await supabase
    .from("recipes")
    .update(payload)
    .eq("id", recipeId)
    .eq("owner_id", ownerId)
    .select(RECIPE_COLUMNS)
    .single();

  if (error) {
    if (isMissingRelationError(error, "recipes")) {
      const cloudRecipes = await loadCloudFallbackRecipes(ownerId);
      const existing = cloudRecipes.find((item) => item.id === recipeId);
      if (!existing) {
        throw error;
      }
      const now = new Date().toISOString();
      const baseLanguage = normalizeRecipeLanguage(input.baseLanguage ?? existing.baseLanguage);
      const translations = buildRecipeTranslations({
        baseLanguage,
        translations: input.translations ?? existing.translations,
        title: payload.title || existing.title,
        shortDescription: payload.short_description,
        description: payload.description,
        instructions: payload.instructions || payload.description || "",
        updatedAt: now,
      });
      const updated: RecipeModel = {
        ...existing,
        title: payload.title || existing.title,
        shortDescription: payload.short_description || "",
        description: payload.description || "",
        instructions: payload.instructions || payload.description || "",
        ingredients: normalizeIngredients(payload.ingredients),
        notes: (input.notes || "").trim(),
        personalTags: normalizePersonalTags(existing.personalTags),
        servings: payload.servings && payload.servings > 0 ? payload.servings : 2,
        image: payload.image || "",
        categories: normalizeStringArray(payload.categories),
        tags: normalizeStringArray(payload.categories),
        baseLanguage,
        translations,
        visibility: normalizeVisibility(payload.visibility),
        shareToken: payload.share_token || undefined,
        updatedAt: now,
      };
      const next = [updated, ...cloudRecipes.filter((item) => item.id !== recipeId)];
      await saveCloudFallbackRecipes(ownerId, next);
      return updated;
    }
    throw error;
  }

  const notes = (input.notes || "").trim();
  let personalTags: string[] = [];
  let hasMetaRow = false;
  const { data: metaRowData, error: metaRowError } = await supabase
    .from("recipe_notes")
    .select("*")
    .eq("recipe_id", recipeId)
    .eq("owner_id", ownerId)
    .maybeSingle();

  if (metaRowError) {
    if (!isMissingRelationError(metaRowError, "recipe_notes")) {
      throw metaRowError;
    }
  } else {
    const metaRow = metaRowData as RecipeNoteRow | null;
    hasMetaRow = Boolean(metaRow);
    personalTags = normalizePersonalTags(metaRow?.personal_tags);
  }

  if (notes || personalTags.length > 0) {
    const payloadWithTags = {
      recipe_id: recipeId,
      owner_id: ownerId,
      notes,
      personal_tags: personalTags,
    };
    let notesError: unknown = null;
    ({ error: notesError } = await supabase
      .from("recipe_notes")
      .upsert(payloadWithTags, { onConflict: "recipe_id" }));

    if (notesError && isMissingColumnError(notesError, "personal_tags")) {
      ({ error: notesError } = await supabase
        .from("recipe_notes")
        .upsert(
          { recipe_id: recipeId, owner_id: ownerId, notes },
          { onConflict: "recipe_id" }
        ));
    }

    if (notesError && !isMissingRelationError(notesError, "recipe_notes")) {
      throw notesError;
    }
  } else if (hasMetaRow) {
    const { error: deleteNoteError } = await supabase
      .from("recipe_notes")
      .delete()
      .eq("recipe_id", recipeId)
      .eq("owner_id", ownerId);
    if (deleteNoteError) {
      if (!isMissingRelationError(deleteNoteError, "recipe_notes")) {
        throw deleteNoteError;
      }
    }
  }

  return mapRow(data as RecipeRow, notes, personalTags);
};

export const updateRecipePersonalTags = async (
  ownerId: string,
  recipeId: string,
  personalTags: string[]
): Promise<string[]> => {
  const normalizedTags = normalizePersonalTags(personalTags);
  const supabase = getSupabaseClient();

  const { data: metaRowData, error: metaRowError } = await supabase
    .from("recipe_notes")
    .select("*")
    .eq("recipe_id", recipeId)
    .eq("owner_id", ownerId)
    .maybeSingle();

  if (metaRowError) {
    if (isMissingRelationError(metaRowError, "recipe_notes")) {
      return normalizedTags;
    }
    throw metaRowError;
  }

  const metaRow = metaRowData as RecipeNoteRow | null;
  const existingNotes = String(metaRow?.notes || "").trim();

  if (normalizedTags.length === 0 && !existingNotes) {
    if (metaRow) {
      const { error: deleteError } = await supabase
        .from("recipe_notes")
        .delete()
        .eq("recipe_id", recipeId)
        .eq("owner_id", ownerId);
      if (deleteError && !isMissingRelationError(deleteError, "recipe_notes")) {
        throw deleteError;
      }
    }
    return [];
  }

  const payloadWithTags = {
    recipe_id: recipeId,
    owner_id: ownerId,
    notes: existingNotes,
    personal_tags: normalizedTags,
  };
  let upsertError: unknown = null;
  ({ error: upsertError } = await supabase
    .from("recipe_notes")
    .upsert(payloadWithTags, { onConflict: "recipe_id" }));

  if (upsertError && isMissingColumnError(upsertError, "personal_tags")) {
    ({ error: upsertError } = await supabase
      .from("recipe_notes")
      .upsert(
        { recipe_id: recipeId, owner_id: ownerId, notes: existingNotes },
        { onConflict: "recipe_id" }
      ));
  }

  if (upsertError && !isMissingRelationError(upsertError, "recipe_notes")) {
    throw upsertError;
  }

  return normalizedTags;
};

export const deleteRecipe = async (ownerId: string, recipeId: string): Promise<void> => {
  const supabase = getSupabaseClient();
  const { error } = await supabase.from("recipes").delete().eq("id", recipeId).eq("owner_id", ownerId);
  if (error) {
    if (isMissingRelationError(error, "recipes")) {
      const cloudRecipes = await loadCloudFallbackRecipes(ownerId);
      const next = cloudRecipes.filter((item) => item.id !== recipeId);
      await saveCloudFallbackRecipes(ownerId, next);
      return;
    }
    throw error;
  }
};

export const deleteAllMyRecipes = async (ownerId: string): Promise<void> => {
  const supabase = getSupabaseClient();
  const { error } = await supabase.from("recipes").delete().eq("owner_id", ownerId);
  if (error) {
    if (isMissingRelationError(error, "recipes")) {
      await saveCloudFallbackRecipes(ownerId, []);
      return;
    }
    throw error;
  }
};

export const copyPublicRecipeToMine = async (ownerId: string, recipeId: string): Promise<RecipeModel> => {
  const supabase = getSupabaseClient();
  const seedTemplate = getSeedTemplateRecipeById(recipeId);

  if (seedTemplate) {
    const payload = {
      owner_id: ownerId,
      author_id: ownerId,
      title: seedTemplate.title,
      short_description: seedTemplate.shortDescription || "",
      description: seedTemplate.description || "",
      instructions: seedTemplate.instructions || "",
      ingredients: normalizeIngredients(seedTemplate.ingredients),
      servings: seedTemplate.servings && seedTemplate.servings > 0 ? seedTemplate.servings : 2,
      image: seedTemplate.image || "",
      categories: [...(seedTemplate.tags || seedTemplate.categories || [])],
      visibility: "private" as RecipeVisibility,
    };

    const existing = await findOwnedRecipeByTitleSafe(ownerId, payload.title);
    if (existing) return existing;

    let copySeedResponse = await supabase
      .from("recipes")
      .insert(payload)
      .select(RECIPE_COLUMNS)
      .single();

    if (copySeedResponse.error && isMissingColumnError(copySeedResponse.error, "author_id")) {
      const { author_id, ...legacyPayload } = payload;
      void author_id;
      copySeedResponse = await supabase
        .from("recipes")
        .insert(legacyPayload)
        .select(RECIPE_COLUMNS)
        .single();
    }

    const { data, error } = copySeedResponse;

    if (error) {
      if (isMissingRelationError(error, "recipes")) {
        const cloudRecipes = await loadCloudFallbackRecipes(ownerId);
        const targetTitle = normalizeTitle(payload.title);
        const existingCloud = cloudRecipes.find((item) => normalizeTitle(item.title || "") === targetTitle);
        if (existingCloud) return existingCloud;
        const now = new Date().toISOString();
        const created: RecipeModel = {
          id: crypto.randomUUID(),
          ownerId,
          authorId: ownerId,
          type: "user",
          isTemplate: false,
          title: payload.title || "Рецепт",
          shortDescription: payload.short_description || "",
          description: payload.description || "",
          instructions: payload.instructions || payload.description || "",
          ingredients: normalizeIngredients(payload.ingredients),
          notes: "",
          personalTags: [],
          servings: payload.servings && payload.servings > 0 ? payload.servings : 2,
          image: payload.image || "",
          categories: normalizeStringArray(payload.categories),
          tags: normalizeStringArray(payload.categories),
          baseLanguage: seedTemplate.baseLanguage || "ru",
          translations: buildRecipeTranslations({
            baseLanguage: seedTemplate.baseLanguage || "ru",
            translations: seedTemplate.translations,
            title: payload.title || "Рецепт",
            shortDescription: payload.short_description,
            description: payload.description,
            instructions: payload.instructions || payload.description || "",
            updatedAt: now,
          }),
          visibility: "private",
          createdAt: now,
          updatedAt: now,
        };
        await saveCloudFallbackRecipes(ownerId, [created, ...cloudRecipes]);
        return created;
      }
      if (isDuplicateKeyError(error)) {
        const existing = await findOwnedRecipeByTitle(ownerId, payload.title);
        if (existing) return existing;
      }
      throw error;
    }

    return mapRow(data as RecipeRow);
  }

  let sourceResponse = await supabase
    .from("recipes")
    .select(RECIPE_COLUMNS_WITH_AUTHOR)
    .eq("id", recipeId)
    .eq("visibility", "public")
    .single();

  if (sourceResponse.error && isMissingColumnError(sourceResponse.error, "author_id")) {
    sourceResponse = await supabase
      .from("recipes")
      .select(RECIPE_COLUMNS)
      .eq("id", recipeId)
      .eq("visibility", "public")
      .single() as typeof sourceResponse;
  }

  const { data: sourceData, error: sourceError } = sourceResponse;

  if (sourceError) {
    throw sourceError;
  }

  const source = sourceData as RecipeRow;
  const payload = {
    owner_id: ownerId,
    author_id: source.author_id || source.owner_id || ownerId,
    title: source.title,
    short_description: source.short_description || "",
    description: source.description || "",
    instructions: source.instructions || "",
    ingredients: normalizeIngredients(source.ingredients),
    servings: source.servings && source.servings > 0 ? source.servings : 2,
    image: source.image || "",
    categories: Array.isArray(source.categories) ? source.categories : [],
    visibility: "private" as RecipeVisibility,
  };

  const existing = await findOwnedRecipeByTitleSafe(ownerId, payload.title);
  if (existing) return existing;

  let copyPublicResponse = await supabase
    .from("recipes")
    .insert(payload)
    .select(RECIPE_COLUMNS)
    .single();

  if (copyPublicResponse.error && isMissingColumnError(copyPublicResponse.error, "author_id")) {
    const { author_id, ...legacyPayload } = payload;
    void author_id;
    copyPublicResponse = await supabase
      .from("recipes")
      .insert(legacyPayload)
      .select(RECIPE_COLUMNS)
      .single();
  }

  const { data, error } = copyPublicResponse;

  if (error) {
    if (isMissingRelationError(error, "recipes")) {
      const cloudRecipes = await loadCloudFallbackRecipes(ownerId);
      const targetTitle = normalizeTitle(payload.title);
      const existingCloud = cloudRecipes.find((item) => normalizeTitle(item.title || "") === targetTitle);
      if (existingCloud) return existingCloud;
      const now = new Date().toISOString();
      const created: RecipeModel = {
        id: crypto.randomUUID(),
        ownerId,
        authorId: String(payload.author_id || ownerId).trim() || ownerId,
        type: "user",
        isTemplate: false,
        title: payload.title || "Рецепт",
        shortDescription: payload.short_description || "",
        description: payload.description || "",
        instructions: payload.instructions || payload.description || "",
        ingredients: normalizeIngredients(payload.ingredients),
        notes: "",
        personalTags: [],
        servings: payload.servings && payload.servings > 0 ? payload.servings : 2,
        image: payload.image || "",
        categories: normalizeStringArray(payload.categories),
        tags: normalizeStringArray(payload.categories),
        baseLanguage: "ru",
        translations: buildRecipeTranslations({
          baseLanguage: "ru",
          title: payload.title || "Рецепт",
          shortDescription: payload.short_description,
          description: payload.description,
          instructions: payload.instructions || payload.description || "",
          updatedAt: now,
        }),
        visibility: "private",
        createdAt: now,
        updatedAt: now,
      };
      await saveCloudFallbackRecipes(ownerId, [created, ...cloudRecipes]);
      return created;
    }
    if (isDuplicateKeyError(error)) {
      const existing = await findOwnedRecipeByTitle(ownerId, payload.title);
      if (existing) return existing;
    }
    throw error;
  }

  return mapRow(data as RecipeRow);
};

export interface RecipeAccessEntry {
  userId: string;
  role: "viewer" | "editor";
}

export interface RecipeAccessEmailEntry {
  email: string;
  role: "viewer" | "editor";
}

export interface RecipeAccessInviteSendResult {
  sent: string[];
  failed: Array<{ email: string; message: string }>;
}

const normalizeInviteEmails = (emails: string[]): string[] => {
  const unique = new Set<string>();
  emails
    .map((item) => String(item || "").trim().toLowerCase())
    .filter(Boolean)
    .forEach((email) => unique.add(email));
  return Array.from(unique);
};

const toErrorMessage = (error: unknown): string => {
  if (error instanceof Error && error.message) return error.message;
  if (error && typeof error === "object" && "message" in error) {
    const text = String((error as { message?: unknown }).message || "");
    if (text) return text;
  }
  return "Не удалось отправить приглашение.";
};

export const sendRecipeAccessInvites = async (
  recipeId: string,
  emails: string[]
): Promise<RecipeAccessInviteSendResult> => {
  const supabase = getSupabaseClient();
  const normalizedEmails = normalizeInviteEmails(emails);
  if (normalizedEmails.length === 0) return { sent: [], failed: [] };

  const origin = typeof window !== "undefined" ? window.location.origin : "";
  const baseRecipeUrl = origin
    ? `${origin}/recipes/${encodeURIComponent(recipeId)}`
    : undefined;
  const redirectTo = baseRecipeUrl ? `${baseRecipeUrl}?invited=1` : undefined;

  const sent: string[] = [];
  const failed: Array<{ email: string; message: string }> = [];

  for (const email of normalizedEmails) {
    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        shouldCreateUser: true,
        emailRedirectTo: redirectTo,
      },
    });

    if (error) {
      failed.push({ email, message: toErrorMessage(error) });
      continue;
    }
    sent.push(email);
  }

  return { sent, failed };
};

export const listRecipeAccessEmails = async (
  _ownerId: string,
  recipeId: string
): Promise<RecipeAccessEmailEntry[]> => {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase.rpc("list_recipe_access_emails", {
    p_recipe_id: recipeId,
  });

  if (error) {
    if (isMissingFunctionError(error, "list_recipe_access_emails")) return [];
    throw error;
  }

  const rows = Array.isArray(data) ? (data as RecipeAccessEmailRpcRow[]) : [];
  return rows
    .map((row) => ({
      email: String(row.email || "").trim().toLowerCase(),
      role: (row.role === "editor" ? "editor" : "viewer") as "viewer" | "editor",
    }))
    .filter((entry) => entry.email.length > 0);
};

export const replaceRecipeAccessByEmail = async (
  _ownerId: string,
  recipeId: string,
  emails: string[],
  role: "viewer" | "editor" = "viewer"
): Promise<void> => {
  const supabase = getSupabaseClient();
  const normalizedEmails = normalizeInviteEmails(emails);
  const { error } = await supabase.rpc("replace_recipe_access_by_email", {
    p_recipe_id: recipeId,
    p_emails: normalizedEmails,
    p_role: role === "editor" ? "editor" : "viewer",
  });

  if (error) {
    if (isMissingFunctionError(error, "replace_recipe_access_by_email")) {
      throw new Error(
        "В Supabase не применено обновление доступа. Откройте SQL Editor и выполните supabase/schema.sql."
      );
    }
    throw error;
  }
};

export const listRecipeAccessEntries = async (
  _ownerId: string,
  recipeId: string
): Promise<RecipeAccessEntry[]> => {
  const supabase = getSupabaseClient();
  const { data, error } = await supabase
    .from("recipe_access")
    .select("recipe_id,user_id,role")
    .eq("recipe_id", recipeId);

  if (error) {
    if (isMissingRelationError(error, "recipe_access")) return [];
    throw error;
  }

  const rows = (data || []) as RecipeAccessRow[];
  return rows
    .filter((row) => row.recipe_id === recipeId && typeof row.user_id === "string" && row.user_id.length > 0)
    .map((row) => ({
      userId: row.user_id,
      role: row.role === "editor" ? "editor" : "viewer",
    }));
};

export const replaceRecipeAccessEntries = async (
  _ownerId: string,
  recipeId: string,
  entries: RecipeAccessEntry[]
): Promise<void> => {
  const supabase = getSupabaseClient();
  const normalizedEntries = entries
    .map((entry) => ({
      recipe_id: recipeId,
      user_id: String(entry.userId || "").trim(),
      role: entry.role === "editor" ? "editor" : "viewer",
    }))
    .filter((entry) => entry.user_id.length > 0);

  const { error: deleteError } = await supabase
    .from("recipe_access")
    .delete()
    .eq("recipe_id", recipeId);
  if (deleteError) {
    if (!isMissingRelationError(deleteError, "recipe_access")) {
      throw deleteError;
    }
    return;
  }

  if (normalizedEntries.length === 0) return;

  const { error: insertError } = await supabase.from("recipe_access").insert(normalizedEntries);
  if (insertError) {
    if (isMissingRelationError(insertError, "recipe_access")) return;
    throw insertError;
  }
};

export const importLocalRecipesIfNeeded = async (ownerId: string): Promise<number> => {
  if (typeof window === "undefined") return 0;

  const supabase = getSupabaseClient();
  const local = loadLocalRecipes();
  if (local.length === 0) return 0;

  const { count, error: countError } = await supabase
    .from("recipes")
    .select("id", { count: "exact", head: true })
    .eq("owner_id", ownerId);

  if (countError) {
    if (isMissingRelationError(countError, "recipes")) {
      const cloud = await loadCloudFallbackRecipes(ownerId);
      if (cloud.length > 0) return 0;
      let importedFallback = 0;
      for (const item of local) {
        const created = await createRecipe(ownerId, {
          title: item.title,
          shortDescription: item.shortDescription,
          description: item.description,
          instructions: item.instructions || item.description,
          ingredients: item.ingredients || [],
          notes: item.notes,
          servings: item.servings,
          image: item.image,
          categories: item.categories,
          tags: item.tags || item.categories,
          visibility: "private",
        });
        if (created.id) importedFallback += 1;
      }
      return importedFallback;
    }
    throw countError;
  }
  if ((count || 0) > 0) return 0;

  let imported = 0;
  for (const item of local) {
    const created = await createRecipe(ownerId, {
      title: item.title,
      shortDescription: item.shortDescription,
      description: item.description,
      instructions: item.instructions || item.description,
      ingredients: item.ingredients || [],
      notes: item.notes,
      servings: item.servings,
      image: item.image,
      categories: item.categories,
      tags: item.tags || item.categories,
      visibility: "private",
    });

    if (created.id) {
      imported += 1;
    }
  }

  return imported;
};

